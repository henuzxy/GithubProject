/*vector是如何增长的*/
为了支持快速随机访问，vector将元素连续存储.
当没有空间容纳新元素时，容器会申请一段新的空间来保存已有的元素和新元素，并将已有元素从旧位置移动到新空间。
注意：并不是每次有新元素添加，就会执行申请新空间。mZ。当申请新空间时，会分配一个比需要的更大的一个空间作为保留，可以保存更多的元素。

/*size,capacity,reserve*/
size是只当前容器已经保存的元素的数目。capacity是再不分配新的内存空间下，能保存最多元素个数.reserve(n)重新分配至少能容纳n个元素的空间,如果当前的n小于size那么该语句不会起作用.

/*泛型算法*/
一般算法再algorithm头文件,一些数值泛型算法再numeric中.
accumulate();
equal();

/*lambda表达式*/
lambda expression
一个lambda表达式表示一个可调用的代码单元。可以理解为一个匿名的内联函数。但与函数不同的是，lambda只能定义再函数内部
形式: [capture list](parameter list) -> return tyep{function body}

lambda的捕获有以下几种:
    值捕获:被捕获的变量是在lambda创建时拷贝。[value](){};
    引用捕获:引用变量。[&value](){}
    隐式捕获:根据lambda中的代码来推断我们使用哪些变量。值捕获:[&](){},引用捕获:[=](){}.注意没有[&,=]这种形式，但可以[=,&value]这种混用。(在混用时，捕获列表第一个元素必须时&或=)

对于被捕获的变量，无法改变其值。如:
    int v = 10;
    auto f = [v](){return --v};//这里会报错，因为捕获的值是不能改变的
如果想要改变捕获的值，那么要使用mutable
    int v = 10;
    auto f = [v]() mutable{return --v};
    f();//这里就可以成功调用了。外部的值不会改变,因为这里是值捕获.

