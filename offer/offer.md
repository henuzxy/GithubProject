1. 为什么连接是三次握手，而断开确实四次挥手?

   因为建立连接的时候，双方没有数据的来往，可以把ACK和SYN放到一个报文进行发送。

   但在关闭连接时，收到FIN报文后，它表示对方没有数据需要再发送了，但自己可能还有数据要发给对方，这是发送一个ACK报文，表示自己收到了FIN报文。当自己也没有数据需要发送的时候，就发送一个FIN表示你现在同意关闭连接了，对面再发送一个ACK即完成断开。

2. 为什么CLIENT主机最后一次发送ACK后不立即断开，而是经过TIME_WAIT状态经过2MSL(最大报文生存时间)后才返回到CLOSE状态？

   因为网络时不可靠的，有可能最后一个ACK会丢失，SERVER端如果没有收到ACK，会再次发送FIN报文，所以CLIENT主机不能立即关闭，他需要确认SERVER端收到了ACK。CLIENT进入TIME_OUT状态后，会设置一个计时器，等待2MSL后进入CLOSE状态，如果在这个时间内再次收到FIN，就会重新发送ACK，并重新等待2MSL.

3. 为什么不能用两次握手进行连接？

   - 防止已经失效的连接请求报文又传到服务器，因而产生错误。当client发送一个请求连接后，在某个网络节点发生延迟，某个时间才到达server端，本来这是一个失效的报文。但B受到后，会发送一个SYN+ACK，如果这时采用的是两次握手，那么表示已经建立连接，但A端这时可能并没有要求建立连接，这样就会造成资源浪费。
   - 在不可靠的信道上可靠的传输信息。如果是两次握手就完成连接的话，当server端发送SYN+ACK之后。如果这条消息并未发送成功，那么CLIENT会继续发送SYN，这样server端会建立多个无效连接。
   - 确保双方对序列号达成一致，当server发送SYN+ACK+seq，表示自己从这个序列号开始发送，但无法确保这个消息被成功发送，必须收到ACK后，才能确定双方对序列号达成一致。best

4. 如果已经建立连接，但客户端出现故障会怎么办？

5. 如何优雅的断开套接字连接？

   close函数意味着完全断开连接。A主机发送完数据后，调用close关闭连接，之后再也无法接收主机B传输的数据。这时就可以使用半关闭，考虑这种情况，服务端将约定的文件发送给客户端后，客户端收到后发送“Thank you”字符串给服务端。
   
6. 什么时候会出现大量的TIME-WAIT状态？

   当请求量很大，并且大多是短连接请求的时候，就会在服务器出现大量的TIME-WAIT状态。
   
7. http的缺点有哪些？
	- 使用明文（不加密），内容可能会被窃听
	- 不验证通信方的身份，因此有可能遭遇伪装
	- 无法验证报文的完整性，可能被修改
	
8. 如何防止报文被窃听？

   1. 对通信加密，即通过SSL建立安全的通信线路，之后在这个线路上进行http通信。
   2. 对内容加密，即把http报文所包含的内容进行加密，但要求客户端和服务端都要具有**加密和解密**机制。当该方式内容有可能被修改。因为通信通道无法保证是安全的。

9. 不验证通信的身份会有哪些隐患?

   1. 无法确定自己发送的目标服务器是否是伪装服务器。同理，无法判断是否伪装客户端。
   2. 无法确定对方对于某些资源是否具有访问权限。
   3. 无意义的请求也会被接收，无法阻止DOS攻击

10. 边缘触发相对条件触发的优点？

    可以分离接收数据和处理数据的时间点。比如服务器从客户端A,B,C接收数据，可能会出现一下情况，即C，B正在发送数据，但A还未连接。可以通过边缘触发，服务器也能决定读取和处理这些数据的时间点。

11.条件触发无法做到区分数据接收和处理吗？

​		可以，但在输入缓冲收到数据时，每次调用epoll\_wait函数都会产生相应的事件，而且事件数会累加，服务器会又很大的负担。

12.sizeof和strlen的区别？

​	sizeof是一个运算符，求目标内存的字节数，和其内容无关。而且sizeof是在编译时计算，不能用来返回动态内存的大小。strlen是计算一个字符串的长度读取到\0位置，比如`char s[] = {'1','2','\0','3'}`获得的长度也是2.

13.strcpy和strncpy的缺陷分析.

	1. 内存越界，当dest的长度小于src的长度时，该函数不会判断目标数组的长度，所以会造成内存越界。
 	2. 当二者长度相等时，会丢失'\0';
 	3. 对于strncpy当src的长度小于Count,时，会不断地在后面补充\0;

14.malloc最大能分配的空间数?

​	Linux下一般为3G，windows下一般为2G,不过通常情况下无法申请到地址空间的上限，因为存在内存碎片，当剩余的空间不是连续内存的时候也会失败。

15.处理哈希冲突的方法？

 1. 开放定址法

    把哈希结果加上一个增量序列，再对哈希表长度取膜，直到不再冲突为止。

2. 再哈希法

   利用不同的哈希函数，即在发生冲突时计算另一个哈希函数的地址，直到不再发生冲突为止。

3. 链地址法

   将哈希结果相同的值记录在同一个线性链表中，

4. 建立公共溢出区

   建立一个溢出区，不管得到的哈希地址是什么，一旦发生冲突都放入这个溢出区。同理查找时也是在这里查找。

16. 如何判断new是否分配成功？什么情况下会分配失败？

    1. 检查返回的是否是个空值，即是否为0。
    2. 会抛出一个bad_alloc的异常（默认时抛出的）

    失败情况：在申请一个很大的内存时，但分配的堆里面没有这么大的内存。

17.C++ 多态，动态绑定的原理?

1. 编译器在父子按类中有虚函数时，会自动为每个类的虚函数生成一份虚函数表。该表是一个一维数组，虚表保存每个虚函数的入口地址。
2. 编译器会在每个类的里面保存一个虚表指针，即指向类所属的虚函数，根据对象的类型去初始化这个虚指针，让其指向正确的虚表。从而找到正确的函数

> 当子类对父类的虚函数没有重写时，子类的虚表指针保存的是父类的虚表，当子类对父类重写时，子类虚表指针保存的是子类的虚表。当子类有自己的虚函数时，在虚表中将此虚函数地址添加到后面。

	3. 程序运行时，会自动调用构造函数，在构造函数中创建虚表并对虚表进行初始化。构造子类对象时，会先调用父类的构造函数，再调用子类的构造函数。

18.结构体大小计算。

```cpp
class A{
public:
    short v;
    char ch;
    int x;
    long long c;
};
class B{
public:
    short v;
    int x;
    char ch;
    long long c;
};
```

A 和B 只是排列的不同，但A的大小时16B,而B时24B.

因为为了CPU能够快速访问，提高访问效率，变量的起始地址应该具有某些特性，这就是所谓的“对齐”。比如4字节的int型变量，那它的起始地址就应该在4字节的边界上，即起始地址可以被4整除

对于A其成员变量起始地址为: v 0, ch 2,x 4,c ,8。因此总大小是16.

对于B其成员变量其实地址为: v 0, x 4,ch 8,c 16。因此总大小是24. 

19.C++程序编译的四个阶段。

​	对于hello.c这个文件

1. 预处理阶段。

   编译器把C程序的头文件插入进来，还有宏的替换。把hello.c预处理为hello.i

2. 编译阶段

   这个阶段主要做词法分析，语法分析，语义检查。检查无错误后，把代码翻译成汇编语言。把hello.i编译为hello.s

3. 汇编阶段

   把汇编语言翻译成机器语言保存到hello.o(二进制文本)

4. 链接阶段

   把.o文件链接成可执行文件。

   这里，如果我们使用了printf函数，再预编译阶段包含进去的stdio.h也只有该函数的声明，而没有该函数的实现，系统把这些实现都放到stdc++的库文件下面了，再没有特别指定是，g++会从/usr/lib里面查找。

20.已连接的UDP套接字和TCP有什么区别？

1. 给UDP套接字调用connect并不会像TCP一样发出三次握手，内核只是检查是否合法