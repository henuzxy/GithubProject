compiler commond
g++ name.cpp -o name

g++ name.cpp -o name -std=c++11
//use C++11 compiler

g++ name.cpp -o name -lpthread
//编译时使用链接线程库
g++ name.cpp -o name -D_REENTRANT -lpthread
//使用-D_REENTRANT会在编译时使用的是线程安全的函数。
./name
/*多文件编译*/
gcc name01.c name02.c -o name//name02.c被name01.c调用，或者相反
cat /proc/sys/kernel/osrelease
//show linux version

vim -r name
//恢复.swp文件
rm -rf dir

/*将文件推送到github仓库*/
git add filename//将文件添加到暂存区
git commit -m "info"//提交本次修改
git push origin master//推送到远程仓库的master分支

/*git从github拉取分支更新本地代码*/
git fetch origin master:temp//拉取远程的master分支，作为本地temp分支
git merge temp//temp与本地分支合并
git branch -d temp//删除暂存的temp分支

git rm fiel(删除文件)
git rm -r aaa(删除文件夹)
%lx %x %lX %X 输出32位，64位的数的十六进制形式。

INADDR_NONE 的值是0xFFFFFFFF表示无效的IP地址。调用inet_addr，失败时返回这个值
可以通过这里判断传入的是否为一个IP

C 语言里面没有重载，函数重载等等都没有。
// /* 向后搜索; ?*向前搜索
atoi();//把一个字符串转换为整数，遇到abc这种错误格式会返回0，遇到12.4这种小数会返回12
bzero(void *s,int n);//把前n个字节置位0，现在用memset()代替
strncasecmp(void *s1,void *s2,int n);
strcasecmp(void *s1,void *s2);//忽略大小写比较
strcmp(void *s1,void *s2);
strncmp(void *s1,void *s2,int n);

size_t strcspn(const char *s,const char *reject);
从s开始，计算不在reject内的字符个数,遇到reject所含有的字符便停止.
char* strstr(char *s1,char *s2);//返回匹配串的首个地址

一个进程的内存空间：数据区(全局区域)，堆区域，栈区域。
全局变量，静态变量，const常量存放在全局区。
函数运行使用栈
new，malloc等函数动态分配提供堆空间
临界区:函数内同时运行多个线程时，引发问题的多条语句构成的代码块。
不是某个区域，而是一个代码块

int dup(int oldfd);
调用dup函数时，内核在进程中创建一个新的文件描述符，此文件描述符是当前可用文件描述符的最小数值,这个文件描述符指向oldfd的文件
char *strtok(char s[],const char*delim);
//分割字符串作用，不过会破坏原有的字符串，把对应的delim变为\0,首次调用s设置为要分解的字符串，以后把s设置为NULL。
/*TCP与UDP*/
1.TCP有流控制，UDP无流控制这是最大的区别
2.TCP数据传输中不存在边界,可以对多次的传输一次接收.UDP的传输存在传输边界,IO次数很重要

char str[] = "hello," "This word"
对于多个""引用,在C语言里面会合并成一个字符串处理

static修饰的函数和普通函数
static修饰的函数只能在本文件中使用，不能被其他文件所调用，普通的函数，默认是extern的，可以被其他文件所调用。
静态函数优点:
    1.在其他文件中可以定义相同名称的函数，不会发生冲突.
    2.保证该函数只能在该文件下使用

#include<getopt.h>
extern char *optarg;
extern int optind,opterr,optopt;
getopt_long(int argc,char* const argv[],const char* optstring,const struct option* longopts,int* longindex);

optstring:短字符选项
longopts:长字符选项
longindex:如果非空，它指向的变量将记录当前参数符合longopts里面的位置，即longopts的下标
struct option{
    const char *name;
    int has_arg;
    int *flag;
    int val;
}
/*当参数flag == NULL时，返回val的值.否则*flag = val,返回0*/
has_arg的参数有
no_argument:表明长选项不带参数，如--help,--version
required_argument:表明长选项必须带参数,如--time 30,--port 8080
optional_argument:表明长选项的参数是可选的,如--clients 100,--clients

/*全局变量的意义*/
optarg:指向当前选项参数的指针,如果当前选项没有参数，指向NULL
optind:调用getopt()时下一个argv指针的索引
optopt:最后一个未知选项
opterr:如果不希望getopt()打印报错信息，只需要把opterr = 0;

/*volatile关键字*/
易变的，相当于告知编译器这是一个容易改变的变量，不要对它进行优化，每次都要到变量的地址去读取变量的数据，这个数据是保存在内存中，不要把他装入寄存器.
例如:
    int a = 1;
    a = 2;
    a = 3;
这种代码对编译器而言，会认为是a = 3,把a存在一个寄存器中，每次遇到a都在这个寄存器中读取，但a可能是该百年的，在中断，或者多进程。

/*僵尸进程*/
向exit()函数传递参数和main()函数的返回值都会传递给操作系统。然而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程。处于这种状态下的进程就是僵尸进程。
/*一个僵尸进程产成的示例:zombie.c*/
int main(int argc,char *argv[]){
    pid_t pid = fork();
    if(pid == 0){
        fprintf(stdout,"child process.\n");
    }
    else{
        fprintf(stdout,"child process ID:%d\n",pid);
        sleep(20);
    }
    if(pid == 0){
        fprintf(stdout,"End child process\n");
    }
    else{
        fprintf(stdout,"End parent process.\n");
    }
    return 0;
}
子进程结束后，父进程仍在执行sleep,这时子进程就变为僵尸进程。

ps au//查看进程列表

/*销毁僵尸进程*/
父进程主动获取子进程的结束状态值,这样便可以销毁子进程.
1.利用wait()函数
#include<sys/wait.h>
pid_t wait(int *statloc);
调用该函数时，如果已经有子进程终止，那么子进程终止时传递的返回值将保存到statloc所指向的内存空间,但该空间还保存有其他信息,需要利用宏来分离.
WIFEXITED();//子进程正常终止时返回真.
WEXITSTATUS();//返回子进程的返回值.
/*调用示例*/
int status;
.......
wait(&status);
if(WIFEXITED(status))
    fprintf(stdout,"Child send:%d\n",WEXITSTATUS(status));


